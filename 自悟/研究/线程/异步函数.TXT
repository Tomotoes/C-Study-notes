C#5.0引入了新的语言特性，称为 异步函数(asynchronous function)
它是 TPL之上的更高级别的抽象，真正简化了 异步编程。

抽象隐藏了 主要的实现细节，使得程序员无须考虑 许多重要的事情。

要创建一个异步函数，【1】首先需要用 async 关键字标注一个方法。
如果不先做这个，就不可能拥有 async 属性或事件访问方法和构造函数。

async Task<string> GetStringAsync()
{
	await Task.Delay(TimeSpan.FromSeconds(2));
	return "Hello World";
}

另一个重要的事：异步函数 【2】必须返回 Task 或 Task<T>类型。

可以使用 async void 方法(此方法 唯一值得去尝试的是 在程序中使用 顶层UI控制器事件处理器)

使用 async 关键字标注的方法内部，可以【3】使用 await 操作符。
该操作符 可与TPL的任务 一起工作，并获取 该任务中异步操作的结果。

并且，我们要知道，在 async方法外不能使用 await 关键字，否则会有编译错误。

另外，异步函数 在其代码中至少 要拥有 一个 await 操作符。
然而，如果没有 只会导致 编译警告，而不是 编译错误。

需要注意的是，在执行完 await 调用的代码行后 该方法会立即返回。

如果 一段方法体中 有多个 await ，它们将会顺序执行。

关联 async 和 await 有一定的限制。不能在 lock,unsafe,main代码块中使用 await 操作符。不允许 对异步函数 使用 ref 或 out 参数

异步函数 会被C#编译器 在后台 编译成 复杂的程序结构，生成的代码很像迭代器。

我想强调 如果方法本来 无需异步或并行执行，那么将该方法 标记为 async 是没有道理的
调用 async 方法会有显著的性能损失。这一点请注意。

有个问题是 如果异步函数被定义一个 Task<string>对象，但实际上返回的是 字符串，却没有编译错误！
这是因为 C#编译器 自动产生了一个 任务并 返回给我们。